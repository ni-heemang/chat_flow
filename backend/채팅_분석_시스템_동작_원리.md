# 채팅 분석 시스템 동작 원리

## 1. 개요

FlowChat 백엔드의 채팅 분석 시스템은 **LLM 기반의 실시간 채팅 분석**을 수행하는 종합적인 시스템입니다. 사용자들이 주고받는 채팅 메시지를 실시간으로 분석하여 키워드, 주제, 감정, 참여도, 시간대별 활동 패턴을 파악합니다.

### 주요 특징
- **LLM 우선 + 폴백 시스템**: OpenAI GPT API를 우선 사용하고, 실패 시 정적 분석으로 전환
- **실시간 분석**: 메시지 수신 즉시 비동기 분석 수행
- **다차원 분석**: 키워드, 주제, 감정, 참여도, 시간 패턴을 종합 분석
- **캐싱 및 성능 최적화**: Spring Cache와 메모리 기반 통계로 빠른 응답
- **WebSocket 실시간 알림**: 분석 결과를 실시간으로 프론트엔드에 전송

## 2. 시스템 아키텍처

```
[채팅 메시지] → [이벤트 발행] → [LLM 분석 서비스] → [결과 저장 & 알림]
                    ↓                    ↓
              [ChatAnalysisService]  [폴백 분석]
                    ↓
              [실시간 통계 업데이트] → [WebSocket 알림] → [프론트엔드]
```

### 핵심 컴포넌트
- **ChatAnalysisService**: 메인 분석 로직 및 통계 관리
- **LlmAnalysisService**: LLM API 호출 및 응답 처리
- **AnalysisNotificationService**: WebSocket을 통한 실시간 알림
- **ConversationFlowService**: 대화 흐름 분석
- **TopicClassificationService**: 폴백용 정적 분류

## 3. 분석 프로세스

### 3.1 메시지 수신 및 이벤트 처리

```java
@EventListener
@Async
public void analyzeMessage(MessageReceivedEvent event) {
    // 1. 시스템 메시지 필터링
    if (message.getMessageType() == ChatMessage.MessageType.SYSTEM) {
        return;
    }
    
    // 2. LLM 기반 비동기 분석 시작
    llmAnalysisService.analyzeMessage(message.getContent())
        .thenAccept(analysisResult -> {
            // 3. 분석 결과 처리
            updateKeywordStats(roomId, keywords);
            updateUserParticipation(roomId, nickname);
            updateHourlyStats(roomId, timestamp);
            
            // 4. 실시간 알림 발송
            analysisNotificationService.onMessageReceived(roomId);
        })
        .exceptionally(throwable -> {
            // 5. LLM 실패 시 폴백 분석
            performFallbackAnalysis(roomId, message, username);
        });
}
```

### 3.2 LLM 기반 종합 분석

**LlmAnalysisService**는 OpenAI GPT API를 통해 다음과 같은 종합 분석을 수행합니다:

#### 분석 프롬프트 예시
```
다음 채팅 메시지를 분석해주세요:
"프로젝트 일정이 너무 빡빡해서 스트레스 받아요..."

다음 JSON 형식으로 응답해주세요:
{
    "keywords": ["프로젝트", "일정", "스트레스"],
    "topic": "업무",
    "emotion": "부정",
    "sentiment_score": -0.6,
    "urgency": "보통",
    "intent": "불만표출",
    "confidence": 0.8
}
```

#### LLM 분석 결과 처리
```java
// 1. 키워드 추출 및 통계 업데이트
List<String> keywords = (List<String>) analysisResult.get("keywords");
updateKeywordStats(roomId, keywords);

// 2. 주제 및 감정 정보 추출
String topic = (String) analysisResult.get("topic");
String emotion = (String) analysisResult.get("emotion");

// 3. 데이터베이스 저장
saveLlmAnalysisResult(roomId, message, analysisResult, keywords, topic, emotion);
```

### 3.3 폴백 분석 시스템

LLM 분석이 실패하거나 응답이 지연될 경우, 정적 분석 방식으로 전환:

```java
private void performFallbackAnalysis(Long roomId, ChatMessage message, String username) {
    // 1. 정적 키워드 추출 (불용어 제거, 빈도 기반)
    List<String> keywords = extractKeywords(message.getContent());
    
    // 2. 룰 기반 주제 분류
    String topic = topicClassificationService.classifyTopic(message.getContent());
    
    // 3. 단순 감정 분석
    String emotion = topicClassificationService.analyzeEmotion(message.getContent());
    
    // 4. 통계 업데이트
    updateKeywordStats(roomId, keywords);
    updateUserParticipation(roomId, nickname);
    updateHourlyStats(roomId, message.getTimestamp());
}
```

## 4. 실시간 통계 관리

### 4.1 메모리 기반 통계 저장

시스템은 빠른 조회를 위해 메모리에 실시간 통계를 유지합니다:

```java
// 채팅방별 키워드 통계
private final Map<Long, Map<String, Integer>> roomKeywordStats = new ConcurrentHashMap<>();

// 사용자별 참여도 통계 (닉네임 기반)
private final Map<Long, Map<String, AtomicInteger>> roomUserMessageCount = new ConcurrentHashMap<>();

// 시간대별 활동 통계
private final Map<Long, Map<Integer, AtomicInteger>> roomHourlyStats = new ConcurrentHashMap<>();
```

### 4.2 통계 업데이트 메서드

```java
private void updateKeywordStats(Long roomId, List<String> keywords) {
    Map<String, Integer> keywordStats = roomKeywordStats.computeIfAbsent(roomId, k -> new ConcurrentHashMap<>());
    for (String keyword : keywords) {
        keywordStats.merge(keyword, 1, Integer::sum);
    }
}

private void updateUserParticipation(Long roomId, String username) {
    Map<String, AtomicInteger> userStats = roomUserMessageCount.computeIfAbsent(roomId, k -> new ConcurrentHashMap<>());
    userStats.computeIfAbsent(username, k -> new AtomicInteger(0)).incrementAndGet();
}
```

## 5. 기간별 분석 시스템

### 5.1 기간별 분석 API

프론트엔드에서 1일, 7일, 30일 등 특정 기간의 분석 결과를 요청할 수 있습니다:

```java
@GetMapping("/rooms/{roomId}/keywords/period/{days}")
public ResponseEntity<Map<String, Object>> getRoomKeywordStatsByPeriod(
    @PathVariable Long roomId, 
    @PathVariable Integer days) {
    
    // 1. 기간 계산
    LocalDateTime cutoffTime = LocalDateTime.now().minusDays(days);
    
    // 2. 데이터베이스에서 기간내 메시지 조회
    List<ChatMessage> messages = chatMessageRepository
        .findByRoomIdAndTimestampAfterAndIsDeletedFalse(roomId, cutoffTime);
    
    // 3. 실시간 키워드 분석 수행
    Map<String, Integer> keywordStats = new HashMap<>();
    for (ChatMessage message : messages) {
        extractAndCountKeywords(message.getContent(), keywordStats);
    }
    
    // 4. 상위 키워드 반환
    return ResponseEntity.ok(createKeywordResponse(keywordStats));
}
```

### 5.2 동적 분석 vs 저장된 분석

- **실시간/기간별 API**: 요청 시점에 데이터베이스에서 메시지를 조회하여 동적 분석
- **저장된 분석**: 주기적으로(매 시간) 분석 결과를 `analysis_results` 테이블에 저장

## 6. 캐싱 전략

### 6.1 Spring Cache 적용

```java
@Cacheable(value = "roomKeywordStats", key = "#roomId")
public Map<String, Object> getRoomKeywordStats(Long roomId) {
    // 메모리 통계 조회 및 캐싱
}

@CacheEvict(value = {"roomKeywordStats", "roomParticipationStats"}, key = "#roomId")
private void evictAnalysisCache(Long roomId) {
    // 새 메시지 분석 시 캐시 무효화
}
```

### 6.2 캐시 무효화 시점

- 새로운 메시지 분석 완료 시
- 분석 데이터 초기화/재구축 시
- 주기적 분석 결과 저장 시

## 7. 데이터베이스 스키마

### 7.1 AnalysisResult 엔티티

```java
@Entity
public class AnalysisResult {
    @Id @GeneratedValue
    private Long id;
    
    private Long roomId;
    private String analysisData;  // JSON 형태의 분석 결과
    
    @Enumerated(EnumType.STRING)
    private AnalysisType analysisType;  // KEYWORD_FREQUENCY, TOPIC_CLASSIFICATION, etc.
    
    private LocalDateTime periodStart;
    private LocalDateTime periodEnd;
    private LocalDateTime createdAt;
    
    // 통계 정보
    private Integer messageCount;
    private Integer userCount;
}
```

### 7.2 분석 결과 저장 형태

```json
{
  "keywords": ["프로젝트", "일정", "스트레스"],
  "topic": "업무",
  "emotion": "부정",
  "messageId": 12345,
  "llm_analysis": {
    "sentiment_score": -0.6,
    "urgency": "보통",
    "confidence": 0.8
  }
}
```

## 8. 실시간 알림 시스템

### 8.1 WebSocket 알림 흐름

```java
// 1. 분석 완료 시 알림 서비스 호출
analysisNotificationService.onMessageReceived(roomId);

// 2. WebSocket을 통해 프론트엔드에 실시간 전송
@MessageMapping("/analysis/subscribe/{roomId}")
public void subscribeToAnalysis(@DestinationVariable Long roomId, StompHeaderAccessor headerAccessor) {
    // 구독 등록 및 실시간 업데이트 전송
}
```

### 8.2 알림 페이로드

```json
{
  "type": "KEYWORD_UPDATE",
  "roomId": 14,
  "data": {
    "topKeywords": [
      {"keyword": "프로젝트", "count": 25},
      {"keyword": "일정", "count": 18}
    ],
    "lastUpdated": "2025-08-26T10:30:00"
  }
}
```

## 9. 성능 최적화 및 스케줄링

### 9.1 비동기 처리

- 모든 분석 작업은 `@Async` 어노테이션으로 비동기 처리
- 메시지 처리 지연 없이 실시간 채팅 가능

### 9.2 주기적 데이터 저장

```java
@Scheduled(cron = "0 0 * * * ?") // 매 시간 정각
public void saveHourlyAnalysisResults() {
    // 메모리의 통계 데이터를 데이터베이스에 영구 저장
    for (Long roomId : roomKeywordStats.keySet()) {
        savePeriodicAnalysisResult(roomId, oneHourAgo, now);
    }
}
```

### 9.3 애플리케이션 시작 시 데이터 복구

```java
@EventListener(ApplicationReadyEvent.class)
public void initializeAnalysisDataOnStartup() {
    // 최근 7일간 활성 채팅방의 분석 데이터 복구
    // 서버 재시작 시에도 분석 통계 유지
}
```

## 10. 에러 처리 및 로깅

### 10.1 다층 에러 처리

1. **LLM API 실패**: 자동으로 폴백 분석으로 전환
2. **JSON 파싱 실패**: 기본값으로 대체
3. **데이터베이스 오류**: 로깅 후 메모리 통계는 유지
4. **네트워크 오류**: 재시도 로직 (RestTemplate 기본 제공)

### 10.2 상세 로깅

```java
logger.debug("LLM 기반 메시지 분석 시작: roomId={}, content={}", roomId, content);
logger.debug("LLM 메시지 분석 완료: roomId={}, keywords={}, topic={}", roomId, keywords, topic);
logger.error("LLM 분석 실패, 폴백 분석 수행: roomId={}, error={}", roomId, throwable.getMessage());
```

## 11. 설정 및 환경변수

### 11.1 LLM 설정

```properties
# LLM 제공자 설정
llm.provider=openai
llm.api.key=${OPENAI_API_KEY}
llm.api.url=https://api.openai.com/v1/chat/completions
llm.model=gpt-3.5-turbo
llm.max-tokens=1000
llm.temperature=0.3
```

### 11.2 캐시 설정

```java
@EnableCaching
@Configuration
public class CacheConfig {
    // Spring Cache 설정
}
```

## 12. API 엔드포인트 요약

| 엔드포인트 | 기능 | 설명 |
|-----------|------|------|
| `GET /api/analysis/rooms/{roomId}/keywords` | 실시간 키워드 통계 | 메모리 기반 실시간 키워드 분석 |
| `GET /api/analysis/rooms/{roomId}/keywords/period/{days}` | 기간별 키워드 분석 | 지정 기간의 동적 키워드 분석 |
| `GET /api/analysis/rooms/{roomId}/participation` | 참여도 통계 | 사용자별 메시지 수 및 참여율 |
| `GET /api/analysis/rooms/{roomId}/participation/period/{days}` | 기간별 참여도 | 지정 기간의 참여도 분석 |
| `GET /api/analysis/rooms/{roomId}/hourly` | 시간대별 통계 | 24시간 활동 패턴 분석 |
| `POST /api/analysis/rooms/{roomId}/rebuild` | 분석 데이터 재구축 | 기존 메시지 기반 통계 재생성 |
| `DELETE /api/analysis/rooms/{roomId}/clear` | 분석 데이터 초기화 | 개발용 데이터 초기화 |

## 13. 향후 개선 방향

### 13.1 고도화 계획
- **다국어 지원**: 영어, 일본어 등 다양한 언어 분석
- **감정 인사이트**: 팀 분위기, 스트레스 지수 등 종합 지표
- **예측 분석**: 대화 패턴 기반 이슈 예측
- **개인화**: 사용자별 맞춤 분석 및 추천

### 13.2 성능 개선
- **Redis 캐시 도입**: 분산 환경에서의 캐시 공유
- **배치 분석**: 대량 메시지의 일괄 분석 최적화
- **LLM 응답 캐싱**: 유사 메시지에 대한 분석 결과 재사용

이 문서는 FlowChat 백엔드의 채팅 분석 시스템이 LLM을 활용하여 어떻게 실시간으로 채팅 내용을 분석하고 인사이트를 제공하는지에 대한 전체적인 동작 원리를 설명합니다.